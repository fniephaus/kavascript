I'm not sure if precedence climbing is possible without an AST.
Though it looks like it should be.

It's a matter of when you insert the operators into the bytecode stream.

2 + 3 * 4
    push 2
    push 3
    add
    push 4
    mul
You have to remember that you had an add operator before.

2 + 3 + 4 * 5
    push 2
    push 3
    add
    push 4
    add
    push 5
    mul

2 * 3 + 4 * 5
    push 2
    push 3
    mul
    push 4
    push 5
    mul
    add # Have to remember this guy, keep it on a stack?

1 == 2 * 3 + 4 * 5
    push 1
    push 2
    push 3
    mul
    push 4
    push 5
    mul
    eq

If we keep a stack of ops, we either run these operators at the very end, unstack
Or when the current operator has lower or equal priority?

7 + 1 == 2 * 3 + 4
    push 7
    push 1
    add # because add has higher priority than ==
    # Stack ==
    push 2
    push 3
    mul # because + has higher priority than +
    push 4
    add # because + has higher priority than == (top of stack)
    eq

If my top of stack operator has higher priority, I run that?
Otherwise I run the latest I just parsed?

This is the shunting yard algorithm: https://en.wikipedia.org/wiki/Shunting_yard_algorithm

-----------------------------------------------------------------------------

There's a bit of an issue with assignments, because you don't know you're parsing an assignment
expression.

At the same time, we don't really want to support multiple assignments in an expression, because
that's really stupid.

We'd like to support simple assignment expressions, such as:
a = 3
a[b] = 3
a[b][c] = 3
a[b][c+2] = 3
a.b.c = 3

At the moment, we run into an issue because if we just parse a,
That's going to read the value of a

We could implement a new operator, such as set a = 3
That would solve this problem and avoid backtracking
Alternatively, *a = 3, or ~a = 3, a mutation operator

Also note that generally, an expression statement on its own isn't super useful.

If you parse an ident, this could be an atomic expression, or it could be an assignment
If you have an array indexing expression, same thing.

With backtracking, you would parse as normal, and when you encounter an assignment, you would
fail and backtrack.

Or maybe we can just remember how many bytecodes we pushed for that last expression,
as well as our position before.

NOTE: normally, you *only* have unary expressions on the lhs of an assignment
Hence, when parsing an atomic expression, you could actually check
am I parsing a the reference or a = 3;

If I'm parsing an assignment, then I parse the rhs recursively and then do
the assignment.

If I'm parsing array indexing, I evaluate the base, then the index, but instead
of reading, I parse the rhs recursively.

There's a potential problem with that though?
a.b.c
parsing a.b, I know it's not an assignment, I evaluate

a[b][c] = 2 + 3
When I find the equal, I assign instead of reading
This seems like it should work.

-----------------------------------------------------------------------------

TODO: make the repo public

TODO: parse if-else statements

TODO: can we make basic assignment parsing work and test it?
- try with just a = b, a = b = c for now
- if you do
    a = b + 1 = c
    this should be invalid? test in Rust.
    1 is an atom, can't be assigned
    a = 1 + b = c
    this fails with 1+b as invalid lhs
=> use an evaluation test for this
TODO: sketch the ordering of operations for some assignments

TODO: fill up table with operators we'll support? some commented out

Note: call, array indexing, member operator have higher priority
than operators such as unary negation (!).
Assignment has least precedence.

That means you should push operators such as unary not on the stack (shouldn't be a problem).

When you reach something like membership or array indexing, ideally you'd like to lookahead
for the next operator. Basically, instead of array read, you'll push an array write. Instead
of member read, you'll push a member write. Maybe we can defer or rewrite the last bytecode
insn? We could even check that the last bytecode insn made sense.
We should also make this check.

-----------------------------------------------------------------------------

TODO: you should add a call stack and have pc be a usize.
- call_stack: Vec<&'static Function> ?
  - that's not super safe either!

How do we want to handle global variables?
In theory, they can just be at the lowest scope level.
We could give them mutable cells if they are captured.
We could also enact the mutable vs immutable distinction,
which would probably simplify a lot of things.
Then we immediately know what's mutable or not.

TODO: add eval tests for variable refs

TODO: implement SetLocal and GetLocal in the VM
- for this, we should have a frame pointer?
  - seems like we definitely need a call stack of functions?

TODO: implement a frame pointer?
- the current fp can be the previous sp, as on arm
- the fp will just be an index into the stack








[DONE] TODO: need to increment num_locals when declaring a variable

[DONE] TODO: implement variable refs

[DONE] TODO: implement let decls

[DONE] TODO: implement basic scope for global unit function
- Maybe we could start with just one Scope object and
  no way to extend it just yet. KISS.

[DONE] TODO: implement Input.parse_ident()

[DONE] TODO: think about basic Scope struct
- Needs a hash map to look up variables in this scope
- Also needs to know the max local idx?
- Technically, we could copy all the data from the parent scope

One problem is that if a variable gets captured, we need to pass it
along when creating the closure.
This is maybe not as complicated as it sounds though, because you parse
the closure body before you create the closure.

This is complicated and it does take away from the fun of this project to some extent.

For now though, there's just one scope.

If I'm in some function and I capture a global, then...?
- I find out through the scope lookup that this function comes from a parent
- I need to mark the function I'm in as capturing a variable
  - And possibly every other function along the way
- Once the function is parsed, we'll pass along the captured variable when
  creating a closure
  - This happens recursively
- The original declaration of the variable needs to change

Maybe for a toy language it's best not to have closures or nested functions?
We can definitely start without this.
We can mark the toplevel function as being the unit function.

Right now I'm mostly curious to know if I can parse assignments correctly.

[DONE] TODO: think, do we want scoping for let decls?
    That would imply we dynamically push a scope in each block
    New variables in the block get a new local idx
    The problem is if a closure gets created in the block...
    It can make that variable long-lived. The host function could
    pop that frame.

    We can simplify that by making captured variables use closure
    cells, but that could be annoying to do with our direct to bytecode parsing.

    Scoping does make the language more complex.
    It means we need a stack of hash maps
    For each block, we push a new scope with local indices
    It also makes some intuitive sense though. Makes for more disciplined programming.

    If we have just one local scope per function, then we just have one local_map
    If a variable gets captured, in theory, we could just replace all uses with a deref
    of a mutable cell

    With multiple scopes, you can do the same thing, but you need to keep track of
    the uses separately.

    Since functions are mutable, we could have a simple push_scope method
    Caveat that scopes are only used during parsing.

    Alternatively, we add a num_locals variable to Function
    And we create a separate Scope or Decls struct that only
    lives during parsing.

    One problem with mutable cells is that in theory, you should be
    creating them right at the let.
    I suppose one easy way to handle this is to have a setlocal insn
    Then we can replace that insn with a make_local_cell insn

[DONE] TODO: implement and test sub
- make sure arg order is correct

[DONE] TODO: we should rename AddI64 to just Add, etc.
- For a demo minimalistic language demo, KISS, no runtime calls

[DONE] TODO: rename Value::Int to Int64

[DONE] TODO: call should have an argc: usize value

[DONE] TODO: explain in readme, design intentionally kept minimalistic and easily readable

[DONE] FIXME: multiplication priority test failing

[DONE] TODO: test priority of mul and add

[DONE] TODO: add support for compiling return
- can then test eval on some arithmetic expressions :)

[DONE] TODO: start by testing compiling empty unit, then unit with just a semicolon

[DONE] TODO: get a basic interpreter going

[DONE] TODO: test that some things fail to parse

[DONE] TODO: test that shunting yard works parsing wise

[DONE] TODO: expression parsing with the shunting yard algorithm

[DONE] TODO: implement unit-level parsing, statements

[DONE] TODO: list features in the readme
- Syntax inspired by JS and C
- Integer and string literals

[DONE] TODO: add support for # or // comments in eat_ws()
- also add a test for it

[PASS] TODO: should we make everything a single file, more self-contained?
- it would simplify things
- makes the project somewhat more approachable?
=> OTOH, multiple modules is good for reuse.