I'm not sure if precedence climbing is possible without an AST.
Though it looks like it should be.

It's a matter of when you insert the operators into the bytecode stream.

2 + 3 * 4
    push 2
    push 3
    add
    push 4
    mul
You have to remember that you had an add operator before.

2 + 3 + 4 * 5
    push 2
    push 3
    add
    push 4
    add
    push 5
    mul

2 * 3 + 4 * 5
    push 2
    push 3
    mul
    push 4
    push 5
    mul
    add # Have to remember this guy, keep it on a stack?

1 == 2 * 3 + 4 * 5
    push 1
    push 2
    push 3
    mul
    push 4
    push 5
    mul
    eq

If we keep a stack of ops, we either run these operators at the very end, unstack
Or when the current operator has lower or equal priority?

7 + 1 == 2 * 3 + 4
    push 7
    push 1
    add # because add has higher priority than ==
    # Stack ==
    push 2
    push 3
    mul # because + has higher priority than +
    push 4
    add # because + has higher priority than == (top of stack)
    eq

If my top of stack operator has higher priority, I run that?
Otherwise I run the latest I just parsed?

This is the shunting yard algorithm: https://en.wikipedia.org/wiki/Shunting_yard_algorithm

-----------------------------------------------------------------------------

There's a bit of an issue with assignments, because you don't know you're parsing an assignment
expression.

At the same time, we don't really want to support multiple assignments in an expression, because
that's really stupid.

We'd like to support simple assignment expressions, such as:
a = 3
a[b] = 3
a[b][c] = 3
a[b][c+2] = 3
a.b.c = 3

At the moment, we run into an issue because if we just parse a,
That's going to read the value of a

We could implement a new operator, such as set a = 3
That would solve this problem and avoid backtracking
Alternatively, *a = 3, or ~a = 3, a mutation operator

Also note that generally, an expression statement on its own isn't super useful.

If you parse an ident, this could be an atomic expression, or it could be an assignment
If you have an array indexing expression, same thing.

With backtracking, you would parse as normal, and when you encounter an assignment, you would
fail and backtrack.

Or maybe we can just remember how many bytecodes we pushed for that last expression,
as well as our position before.

NOTE: normally, you *only* have unary expressions on the lhs of an assignment
Hence, when parsing an atomic expression, you could actually check
am I parsing a the reference or a = 3;

If I'm parsing an assignment, then I parse the rhs recursively and then do
the assignment.

If I'm parsing array indexing, I evaluate the base, then the index, but instead
of reading, I parse the rhs recursively.

There's a potential problem with that though?
a.b.c
parsing a.b, I know it's not an assignment, I evaluate

a[b][c] = 2 + 3
When I find the equal, I assign instead of reading
This seems like it should work.

-----------------------------------------------------------------------------

TODO: make the repo public

TODO: parse if-else statements

TODO: can we make basic assignment parsing work and test it?
- try with just a = b, a = b = c for now
- if you do
    a = b + 1 = c
    this should be invalid? test in Rust.
    1 is an atom, can't be assigned
    a = 1 + b = c
    this fails with 1+b as invalid lhs
=> use an evaluation test for this
TODO: sketch the ordering of operations for some assignments

TODO: fill up table with operators we'll support? some commented out

Note: call, array indexing, member operator have higher priority
than operators such as unary negation (!).
Assignment has least precedence.

That means you should push operators such as unary not on the stack (shouldn't be a problem).

When you reach something like membership or array indexing, ideally you'd like to lookahead
for the next operator. Basically, instead of array read, you'll push an array write. Instead
of member read, you'll push a member write. Maybe we can defer or rewrite the last bytecode
insn? We could even check that the last bytecode insn made sense.
We should also make this check.

TODO: implement let decls

TODO: write some evaluation tests
TODO: you should add a call stack and have pc be a usize.






[DONE] TODO: get a basic interpreter going

[DONE] TODO: test that some things fail to parse

[DONE] TODO: test that shunting yard works parsing wise

[DONE] TODO: expression parsing with the shunting yard algorithm

[DONE] TODO: implement unit-level parsing, statements

[DONE] TODO: list features in the readme
- Syntax inspired by JS and C
- Integer and string literals

[DONE] TODO: add support for # or // comments in eat_ws()
- also add a test for it

[PASS] TODO: should we make everything a single file, more self-contained?
- it would simplify things
- makes the project somewhat more approachable?
=> OTOH, multiple modules is good for reuse.